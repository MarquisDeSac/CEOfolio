---
---

<div class="fixed top-0 bottom-0 left-0 right-0 pointer-events-none print:hidden z-[-1] bg-[#111] overflow-hidden">
  <canvas id="circuit-canvas" class="w-full h-full opacity-30"></canvas>
  <div class="absolute inset-0 bg-gradient-to-b from-transparent to-black opacity-80"></div>
</div>

<script>
  function initCircuit() {
    const canvas = document.getElementById('circuit-canvas') as HTMLCanvasElement
    if (!canvas) return

    const ctx = canvas.getContext('2d')
    if (!ctx) return

    let width = window.innerWidth
    let height = window.innerHeight

    canvas.width = width
    canvas.height = height

    interface Node {
      x: number
      y: number
      connected: boolean
    }

    const gridSize = 40
    const nodes: Node[] = []

    // Create grid nodes
    for (let x = 0; x < width; x += gridSize) {
      for (let y = 0; y < height; y += gridSize) {
        if (Math.random() > 0.7) { // Sparse grid
          nodes.push({ x, y, connected: false })
        }
      }
    }

    const paths: { start: Node, end: Node, progress: number, speed: number }[] = []

    function createPath() {
      if (nodes.length < 2) return
      const start = nodes[Math.floor(Math.random() * nodes.length)]
      let end = nodes[Math.floor(Math.random() * nodes.length)]
      
      // Find a nearby node (simple manhattan distance check)
      let attempts = 0
      while ((Math.abs(start.x - end.x) + Math.abs(start.y - end.y)) > gridSize * 5 || start === end) {
        end = nodes[Math.floor(Math.random() * nodes.length)]
        attempts++
        if (attempts > 10) return
      }

      const colors = ['#ff007f', '#00f3ff', '#bc13fe'] // Pink, Cyan, Purple

      paths.push({
        start,
        end,
        progress: 0,
        speed: Math.random() * 0.005 + 0.002, // Much slower
        color: colors[Math.floor(Math.random() * colors.length)]
      })
    }

    // Initial paths (staggered spawn)
    function spawnInitial() {
        if (paths.length < 15) {
            createPath()
            setTimeout(spawnInitial, 200)
        }
    }
    spawnInitial()

    function draw() {
      // Fade out effect
      ctx.fillStyle = 'rgba(17, 17, 17, 0.1)'
      ctx.fillRect(0, 0, width, height)

      ctx.lineWidth = 2
      ctx.lineCap = 'round'

      for (let i = paths.length - 1; i >= 0; i--) {
        const path = paths[i]
        path.progress += path.speed

        ctx.strokeStyle = path.color // Use path color

        const currentX = path.start.x + (path.end.x - path.start.x) * path.progress
        const currentY = path.start.y + (path.end.y - path.start.y) * path.progress
        
        // Draw segment
        ctx.beginPath()
        // Orthogonal routing logic (simplified: L-shape)
        const midX = path.end.x
        const midY = path.start.y

        if (path.progress < 0.5) {
             const segmentProgress = path.progress * 2
             const segmentX = path.start.x + (midX - path.start.x) * segmentProgress
             const segmentY = path.start.y + (midY - path.start.y) * segmentProgress
             ctx.moveTo(path.start.x, path.start.y)
             ctx.lineTo(segmentX, segmentY)
        } else {
             const segmentProgress = (path.progress - 0.5) * 2
             ctx.moveTo(path.start.x, path.start.y)
             ctx.lineTo(midX, midY)
             const segmentX = midX + (path.end.x - midX) * segmentProgress
             const segmentY = midY + (path.end.y - midY) * segmentProgress
             ctx.lineTo(segmentX, segmentY)
        }

        ctx.shadowBlur = 5
        ctx.shadowColor = path.color
        ctx.stroke()
        ctx.shadowBlur = 0

        if (path.progress >= 1) {
          // Draw a "terminal" dot
          ctx.beginPath()
          ctx.fillStyle = path.color
          ctx.arc(path.end.x, path.end.y, 3, 0, Math.PI * 2)
          ctx.fill()
          
          paths.splice(i, 1)
          createPath() // Spawn new
        }
      }

      // Randomly spawn new paths if count low
      if (paths.length < 15 && Math.random() > 0.95) createPath()

      requestAnimationFrame(draw)
    }

    window.addEventListener('resize', () => {
        width = window.innerWidth
        height = window.innerHeight
        canvas.width = width
        canvas.height = height
    })

    draw()
  }

  document.addEventListener('astro:page-load', initCircuit)
  initCircuit()
</script>
